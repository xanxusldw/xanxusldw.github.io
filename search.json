[{"title":"JobIntentService 异常分析","url":"https://xanxusldw.github.io/2020/03/21/JobIntentService-异常分析/","content":"<p>\b\b最近在看app的监控上可以看到一些JobIntentService异常的日志， \b堆栈如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.RuntimeException : <span class=\"function\">An error occurred <span class=\"keyword\">while</span> executing <span class=\"title\">doInBackground</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.os.AsyncTask$3.<span class=\"title\">done</span><span class=\"params\">(AsyncTask.java:<span class=\"number\">354</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.FutureTask.<span class=\"title\">finishCompletion</span><span class=\"params\">(FutureTask.java:<span class=\"number\">383</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.FutureTask.<span class=\"title\">setException</span><span class=\"params\">(FutureTask.java:<span class=\"number\">252</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.FutureTask.<span class=\"title\">run</span><span class=\"params\">(FutureTask.java:<span class=\"number\">271</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.ThreadPoolExecutor.<span class=\"title\">runWorker</span><span class=\"params\">(ThreadPoolExecutor.java:<span class=\"number\">1167</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.ThreadPoolExecutor$Worker.<span class=\"title\">run</span><span class=\"params\">(ThreadPoolExecutor.java:<span class=\"number\">641</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.lang.Thread.<span class=\"title\">run</span><span class=\"params\">(Thread.java:<span class=\"number\">764</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        Caused by: java.lang.SecurityException : Caller no longer running, last stopped +25ms because: timed out <span class=\"keyword\">while</span> starting</span></span><br><span class=\"line\"><span class=\"function\">        at android.os.Parcel.<span class=\"title\">createException</span><span class=\"params\">(Parcel.java:<span class=\"number\">1950</span>[]</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        at android.os.Parcel.readException(Parcel.java:<span class=\"number\">1918</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.os.Parcel.<span class=\"title\">readException</span><span class=\"params\">(Parcel.java:<span class=\"number\">1868</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.app.job.IJobCallback$Stub$Proxy.<span class=\"title\">dequeueWork</span><span class=\"params\">(IJobCallback.java:<span class=\"number\">195</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.app.job.JobParameters.<span class=\"title\">dequeueWork</span><span class=\"params\">(JobParameters.java:<span class=\"number\">243</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.support.v4.app.JobIntentService$JobServiceEngineImpl.<span class=\"title\">dequeueWork</span><span class=\"params\">(JobIntentService.java:<span class=\"number\">315</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.support.v4.app.JobIntentService.<span class=\"title\">dequeueWork</span><span class=\"params\">(JobIntentService.java:<span class=\"number\">640</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.support.v4.app.JobIntentService$CommandProcessor.<span class=\"title\">doInBackground</span><span class=\"params\">(JobIntentService.java:<span class=\"number\">390</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.support.v4.app.JobIntentService$CommandProcessor.<span class=\"title\">doInBackground</span><span class=\"params\">(JobIntentService.java:<span class=\"number\">383</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.os.AsyncTask$2.<span class=\"title\">call</span><span class=\"params\">(AsyncTask.java:<span class=\"number\">333</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.FutureTask.<span class=\"title\">run</span><span class=\"params\">(FutureTask.java:<span class=\"number\">266</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.ThreadPoolExecutor.<span class=\"title\">runWorker</span><span class=\"params\">(ThreadPoolExecutor.java:<span class=\"number\">1167</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.util.concurrent.ThreadPoolExecutor$Worker.<span class=\"title\">run</span><span class=\"params\">(ThreadPoolExecutor.java:<span class=\"number\">641</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at java.lang.Thread.<span class=\"title\">run</span><span class=\"params\">(Thread.java:<span class=\"number\">764</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        Caused by: android.os.RemoteException : Remote stack trace:</span></span><br><span class=\"line\"><span class=\"function\">        at com.android.server.job.JobServiceContext.<span class=\"title\">assertCallerLocked</span><span class=\"params\">(JobServiceContext.java:<span class=\"number\">481</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at com.android.server.job.JobServiceContext.<span class=\"title\">doDequeueWork</span><span class=\"params\">(JobServiceContext.java:<span class=\"number\">359</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at com.android.server.job.JobServiceContext$JobCallback.<span class=\"title\">dequeueWork</span><span class=\"params\">(JobServiceContext.java:<span class=\"number\">160</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.app.job.IJobCallback$Stub.<span class=\"title\">onTransact</span><span class=\"params\">(IJobCallback.java:<span class=\"number\">83</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        at android.os.Binder.<span class=\"title\">execTransact</span><span class=\"params\">(Binder.java:<span class=\"number\">731</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上面我么可以看到在<strong>dequeueWork</strong>的时候出现了<strong>Caller no longer running, last stopped +25ms because: timed out while starting</strong>,caller 的progress 没有在跑了， 那这个是运行在什么进程上的呢？</p>\n<p>我们可以稍微梳理一下JobIntentService的启动流程时序图：</p>\n<img src=\"/2020/03/21/JobIntentService-%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/JoinIntentServiceWorkFlow.png\" class title=\"JobIntentservice启动流程时序图\">\n\n<p>JobParameters.dequeueWork  这里调用的是 JobServiceContext.JobCallback.dequeueWork， 这个CallBack是在JobServiceContext.executeRunnableJob中初始化的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">executeRunnableJob</span><span class=\"params\">(JobStatus job)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mAvailable) &#123;</span><br><span class=\"line\">            Slog.e(TAG, <span class=\"string\">\"Starting new runnable but context is unavailable &gt; Error.\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mPreferredUid = NO_PREFERRED_UID;</span><br><span class=\"line\"></span><br><span class=\"line\">        mRunningJob = job;</span><br><span class=\"line\">        mRunningCallback = <span class=\"keyword\">new</span> JobCallback();</span><br><span class=\"line\">        <span class=\"comment\">// 此处省略代码。。。。。。</span></span><br><span class=\"line\">        mParams = <span class=\"keyword\">new</span> JobParameters(mRunningCallback, job.getJobId(), ji.getExtras(),</span><br><span class=\"line\">                ji.getTransientExtras(), ji.getClipData(), ji.getClipGrantFlags(),</span><br><span class=\"line\">                isDeadlineExpired, triggeredUris, triggeredAuthorities, job.network);</span><br><span class=\"line\">        mExecutionStartTimeElapsed = sElapsedRealtimeClock.millis();</span><br></pre></td></tr></table></figure>\n<p>\b<br>这个JoboServiceContext 是怎么来的？<br>这个可以\b在JobSchedulerService中查到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Track Services that have currently active or pending jobs. The index is provided by</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> JobStatus#getServiceToken()&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;JobServiceContext&gt; mActiveServices = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** The maximum number of concurrent jobs we run at one time. */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_JOB_CONTEXTS_COUNT = <span class=\"number\">16</span>;</span><br></pre></td></tr></table></figure>\n<p>就是JobSchedulerService在Boot Phase后会生成16个JobServiceContext. 这些Context 就是用来执行pending的Job运行工作的。<br>然后PendingJobs 会被assign 到 空闲的JobServiceContext 上。 这个具体的调度策略可以看JobConcurrencyManager.assignJobsToContextsInternalLocked</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingJobs.size(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> JobStatus nextPending = pendingJobs.get(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Unfortunately we need to repeat this relatively expensive check.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> jobRunningContext = findJobContextIdFromMap(nextPending, contextIdToJobMap);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (jobRunningContext != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isPendingFg = isFgJob(nextPending);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find an available slot for nextPending. The context should be available OR</span></span><br><span class=\"line\">    <span class=\"comment\">// it should have lowest priority among all running jobs</span></span><br><span class=\"line\">    <span class=\"comment\">// (sharing the same Uid as nextPending)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> minPriorityForPreemption = Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> selectedContextId = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> startingJob = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;MAX_JOB_CONTEXTS_COUNT; j++) &#123;</span><br><span class=\"line\">        JobStatus job = contextIdToJobMap[j];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> preferredUid = preferredUidForContext[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (job == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> preferredUidOkay = (preferredUid == nextPending.getUid())</span><br><span class=\"line\">                    || (preferredUid == JobServiceContext.NO_PREFERRED_UID);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (preferredUidOkay &amp;&amp; mJobCountTracker.canJobStart(isPendingFg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// This slot is free, and we haven't yet hit the limit on</span></span><br><span class=\"line\">                <span class=\"comment\">// concurrent jobs...  we can just throw the job in to here.</span></span><br><span class=\"line\">                selectedContextId = j;</span><br><span class=\"line\">                startingJob = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// No job on this context, but nextPending can't run here because</span></span><br><span class=\"line\">            <span class=\"comment\">// the context has a preferred Uid or we have reached the limit on</span></span><br><span class=\"line\">            <span class=\"comment\">// concurrent jobs.</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (job.getUid() != nextPending.getUid()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> jobPriority = mService.evaluateJobPriorityLocked(job);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jobPriority &gt;= nextPending.lastEvaluatedPriority) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// TODO lastEvaluatedPriority should be evaluateJobPriorityLocked. (double check it)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minPriorityForPreemption &gt; nextPending.lastEvaluatedPriority) &#123;</span><br><span class=\"line\">            minPriorityForPreemption = nextPending.lastEvaluatedPriority;</span><br><span class=\"line\">            selectedContextId = j;</span><br><span class=\"line\">            <span class=\"comment\">// In this case, we're just going to preempt a low priority job, we're not</span></span><br><span class=\"line\">            <span class=\"comment\">// actually starting a job, so don't set startingJob.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedContextId != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        contextIdToJobMap[selectedContextId] = nextPending;</span><br><span class=\"line\">        slotChanged[selectedContextId] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (startingJob) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Increase the counters when we're going to start a job.</span></span><br><span class=\"line\">        mJobCountTracker.onStartingNewJob(isPendingFg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那还是回到原来的问题JobServiceContext.JobCallback.dequeueWork 这个运行的线程现在就一目了然，就是跑在了JobSchedulerService这个service上面。<br>JobSchedulerService 是一个系统服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JobSchedulerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">com</span>.<span class=\"title\">android</span>.<span class=\"title\">server</span>.<span class=\"title\">SystemService</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个JobSchedulerService 就是在SystemService启动的时候一起起的服务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startOtherServices</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//…</span></span><br><span class=\"line\">traceBeginAndSlog(<span class=\"string\">\"StartJobScheduler\"</span>);</span><br><span class=\"line\">mSystemServiceManager.startService(JobSchedulerService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">traceEnd();</span><br></pre></td></tr></table></figure>\n<p>也就是说这个Service是随着系统一起启动并运行在System server进程上面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">……</span><br><span class=\"line\"><span class=\"comment\">// Prepare the main looper thread (this thread).</span></span><br><span class=\"line\">android.os.Process.setThreadPriority(</span><br><span class=\"line\">android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class=\"line\">android.os.Process.setCanSelfBackground(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">Looper.prepareMainLooper();</span><br><span class=\"line\">Looper.getMainLooper().setSlowLogThresholdMs(</span><br><span class=\"line\">SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);</span><br><span class=\"line\"><span class=\"comment\">// Initialize native services.</span></span><br><span class=\"line\">System.loadLibrary(<span class=\"string\">\"android_servers”);</span></span><br><span class=\"line\"><span class=\"string\">……</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// Loop forever.</span></span><br><span class=\"line\"><span class=\"string\">Looper.loop();</span></span><br></pre></td></tr></table></figure>\n\n<p>为什么在系统上跑了还会出异常log栈呢？  我们看一下log打出来的地点在JobSchedulerContext</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">assertCallerLocked</span><span class=\"params\">(JobCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!verifyCallerLocked(cb)) &#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">128</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">\"Caller no longer running\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb.mStoppedReason != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sb.append(<span class=\"string\">\", last stopped \"</span>);</span><br><span class=\"line\">            TimeUtils.formatDuration(sElapsedRealtimeClock.millis() - cb.mStoppedTime, sb);</span><br><span class=\"line\">            sb.append(<span class=\"string\">\" because: \"</span>);</span><br><span class=\"line\">            sb.append(cb.mStoppedReason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SecurityException(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是verifyCallerLocked 这个方法校验没成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This class is reused across different clients, and passes itself in as a callback. Check</span></span><br><span class=\"line\"><span class=\"comment\"> * whether the client exercising the callback is the client we expect.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> True if the binder calling is coming from the client we expect.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">verifyCallerLocked</span><span class=\"params\">(JobCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRunningCallback != cb) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) &#123;</span><br><span class=\"line\">            Slog.d(TAG, <span class=\"string\">\"Stale callback received, ignoring.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个校验没有成功是因为mRunningCallBack 和 回调的cb 不一样。  上面我们已经了解过分配策略了， pending job 是跑在空闲的job上的。</p>\n<p>mRunningCallback  会在JobServiceContext 在执行executeRunnableJob的时候进行赋值或者job结束的时候closeAndCleanupJobLocked</p>\n<ol>\n<li>executeRunnableJob<br>这个只有在JobSchedulerService 会给当前空闲的Context分配上pending job才会执行， 什么情况的JobServiceContext算空闲呢？<br>   就是没有Running job 的JobServiceContext， 为空也是在closeAndCleanupJobLocked 上置为空的。我们直接看一下第二个case。</li>\n<li>closeAndCleanupJobLocked<br> 这个执行情况，jobFinish， job cancel， <strong>job操作timeout， job异常了， 任务service连接异常了</strong>。</li>\n</ol>\n<p>也就是说这个crash可能发生的情况就是case 2的加粗的这几种情况，看一下google 有没有这样异常的case。  网上也可以看到类似的case。<br>根据栈的情况Caller no longer running, last stopped +25ms because: timed out while starting</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> VERB_STARTING:</span><br><span class=\"line\">    <span class=\"comment\">// Client unresponsive - wedged or failed to respond in time. We don't really</span></span><br><span class=\"line\">    <span class=\"comment\">// know what happened so let's log it and notify the JobScheduler</span></span><br><span class=\"line\">    <span class=\"comment\">// FINISHED/NO-RETRY.</span></span><br><span class=\"line\">    Slog.w(TAG, <span class=\"string\">\"No response from client for onStartJob \"</span></span><br><span class=\"line\">            + getRunningJobNameLocked());</span><br><span class=\"line\">    closeAndCleanupJobLocked(<span class=\"keyword\">false</span> <span class=\"comment\">/* needsReschedule */</span>, <span class=\"string\">\"timed out while starting\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n<p>就是starting timeout了，  这个timeout是这段代码开始的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Start the job on the service. */</span></span><br><span class=\"line\"><span class=\"meta\">@GuardedBy</span>(<span class=\"string\">\"mLock\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleServiceBoundLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) &#123;</span><br><span class=\"line\">        Slog.d(TAG, <span class=\"string\">\"handleServiceBound for \"</span> + getRunningJobNameLocked());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mVerb != VERB_BINDING) &#123;</span><br><span class=\"line\">        Slog.e(TAG, <span class=\"string\">\"Sending onStartJob for a job that isn't pending. \"</span></span><br><span class=\"line\">                + VERB_STRINGS[mVerb]);</span><br><span class=\"line\">        closeAndCleanupJobLocked(<span class=\"keyword\">false</span> <span class=\"comment\">/* reschedule */</span>, <span class=\"string\">\"started job not pending\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG) &#123;</span><br><span class=\"line\">            Slog.d(TAG, <span class=\"string\">\"Job cancelled while waiting for bind to complete. \"</span></span><br><span class=\"line\">                    + mRunningJob);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        closeAndCleanupJobLocked(<span class=\"keyword\">true</span> <span class=\"comment\">/* reschedule */</span>, <span class=\"string\">\"cancelled while waiting for bind\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        mVerb = VERB_STARTING;</span><br><span class=\"line\">        scheduleOpTimeOutLocked();</span><br><span class=\"line\">        service.startJob(mParams);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We catch 'Exception' because client-app malice or bugs might induce a wide</span></span><br><span class=\"line\">        <span class=\"comment\">// range of possible exception-throw outcomes from startJob() and its handling</span></span><br><span class=\"line\">        <span class=\"comment\">// of the client's ParcelableBundle extras.</span></span><br><span class=\"line\">        Slog.e(TAG, <span class=\"string\">\"Error sending onStart message to '\"</span> +</span><br><span class=\"line\">                mRunningJob.getServiceComponent().getShortClassName() + <span class=\"string\">\"' \"</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后为啥timeout勒</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> JobParameters params = (JobParameters) msg.obj;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MSG_EXECUTE_JOB:</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> workOngoing = JobServiceEngine.<span class=\"keyword\">this</span>.onStartJob(params);</span><br><span class=\"line\">                ackStartMessage(params, workOngoing);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">\"Error while executing job: \"</span> + params.getJobId());</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的就是这里的ackStartMessage没有走到。直接超时了<br>中间经历了什么？ 好好的按规则走 咋就迷路了约定时间还不到。<br>从一开始的流程中可以知道， 这里面没太多步骤<br>scheduleOpTimeOutLocked() -&gt; JobServiceEngine.startJob -&gt; JobHandler.handle(MSG_EXECUTE_JOB)  -&gt; ensureProcessorRunnngLocked -&gt;  ackStartMessage</p>\n<p>标粗的就是几个具体的操作， 按道理这3个操作不会耗费8秒时间呀， 但出现这样的case 说明真的消耗了8s， 哈哈。</p>\n<p>第一个函数可能的case就是， <strong>IPC  binder交互因为某种原因被阻塞了一段时间</strong>，  也有可能， 人家google 也说了不知道什么原因会timeout。<br>第二个函数按道理就是一个handler的回调上的事， 这里的handler 就是切换了一下线程， 从System Service 切换到JobIntentService 线程上面来了，按道理这里可能就是<strong>线程被挂起了， 系统太忙了</strong>， 然后这个后台的JobIntentService只能等一会才能继续操作<br>第三个函数没啥可能太耗时了， 虽然有lock， 但没有死锁的可能，然后就是起个AsyncTAsk了就结束了</p>\n<p>上面的代码都是基于androix.core 1.2.0 的代码， 暂时升级到androidX后没有看到这样堆栈的bug， 这里面的一些系统bug可能google修了。<br>看看google tracker。</p>\n<p><a href=\"https://issuetracker.google.com/issues/63622293\" target=\"_blank\" rel=\"noopener\">Google tracker:Exception</a>   google 上很多人也发生过类似的情况， 网友都说O以上才发生，为什么是O以上呢？</p>\n<p>其实我们也可以从JobIntentService 找到答案</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> WorkEnqueuer <span class=\"title\">getWorkEnqueuer</span><span class=\"params\">(Context context, ComponentName cn, <span class=\"keyword\">boolean</span> hasJobId,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> jobId)</span> </span>&#123;</span><br><span class=\"line\">    WorkEnqueuer we = sClassWorkEnqueuer.get(cn);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (we == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">26</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasJobId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Can't be here without a job id\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            we = <span class=\"keyword\">new</span> JobWorkEnqueuer(context, cn, jobId);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            we = <span class=\"keyword\">new</span> CompatWorkEnqueuer(context, cn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sClassWorkEnqueuer.put(cn, we);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> we;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>O以下走的是CompatWorkEnqueuer这个方式，O以前是没用JobSchedulerService 来执行job的， 而是通过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueueWork</span><span class=\"params\">(Intent work)</span> </span>&#123;</span><br><span class=\"line\">    Intent intent = <span class=\"keyword\">new</span> Intent(work);</span><br><span class=\"line\">    intent.setComponent(mComponentName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Log.d(TAG, <span class=\"string\">\"Starting service for work: \"</span> + work);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mContext.startService(intent) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!mLaunchingService) &#123;</span><br><span class=\"line\">                mLaunchingService = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mServiceProcessing) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If the service is not already holding the wake lock for</span></span><br><span class=\"line\">                    <span class=\"comment\">// itself, acquire it now to keep the system running until</span></span><br><span class=\"line\">                    <span class=\"comment\">// we get this work dispatched.  We use a timeout here to</span></span><br><span class=\"line\">                    <span class=\"comment\">// protect against whatever problem may cause it to not get</span></span><br><span class=\"line\">                    <span class=\"comment\">// the work.</span></span><br><span class=\"line\">                    mLaunchWakeLock.acquire(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没有错 根本没走JobSchedulerService上面的逻辑， 就是直接startService 就开干了~ 所以并不存在上面的case.</p>\n<p>这个问题分析到这里，大致了解了一下这个问题可能的原因和走的逻辑，app性能监控上没有最近没有发现类似的问题,将会继续跟踪观察google tracker上的动态。<br>如果这个必须不让它发生也可以catch 这部分代码的exception.</p>\n","categories":["Android"],"tags":["JobIntentService","Exception"]},{"title":"Android Service Start WorkFlow","url":"https://xanxusldw.github.io/2020/03/21/Android-Service-Start-WorkFlow/","content":"<img src=\"/2020/03/21/Android-Service-Start-WorkFlow/NServiceStartWorkFlow.png\" class title=\"\bServiceStart启动流程时序图\">","categories":["Java"],"tags":["Android Service","workflow"]},{"title":"about","url":"https://xanxusldw.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://xanxusldw.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"https://xanxusldw.github.io/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://xanxusldw.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://xanxusldw.github.io/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://xanxusldw.github.io/search/index.html","content":"","categories":[],"tags":[]}]